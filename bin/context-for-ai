#!/bin/bash

VERSION="VERSION_PLACEHOLDER"
OUT_FILE="project_snapshot.txt"
EXTENSIONS=("kt" "java" "py")
EXTRA_FILES=("pom.xml" "build.gradle.kts" "application.yml" "requirements.txt" "pyproject.toml" "setup.py")

# === Show help ===
show_help() {
  cat << EOF
context-for-ai â€” generate a plain, machine-readable snapshot of your project.

Usage:
  context-for-ai [--help] [--version]

Creates a plain .txt file with full contents of source and config files.
Adds md5 and sha1 checksums before each file.

Files are listed in order:
  1. src/ or src/main/
  2. tests/, test/, or src/test/
  3. others

Output: $OUT_FILE

Options:
  --help        Show this help message
  --version     Show script version
EOF
  exit 0
}

# === Parse arguments ===
for arg in "$@"; do
  case $arg in
    --help)
      show_help
      ;;
    --version)
      echo "context-for-ai $VERSION"
      exit 0
      ;;
  esac
done

# === Start snapshot ===
echo "ðŸ§¾ Creating project snapshot: $OUT_FILE"
echo "" > "$OUT_FILE"

# === Find all relevant source files ===
EXT_PATTERN=""
for ext in "${EXTENSIONS[@]}"; do
  EXT_PATTERN="$EXT_PATTERN -name '*.$ext' -o"
done
EXT_PATTERN="${EXT_PATTERN% -o}"

ALL_FILES=()
while IFS= read -r file; do
  [[ "$file" =~ build/|target/|\.class$|__pycache__ ]] && continue
  ALL_FILES+=("$file")
done < <(eval "find . -type f \( $EXT_PATTERN \)" | sort)

# === Categorize: src/main or src/ â†’ test â†’ other ===
SRC_FILES=()
TEST_FILES=()
OTHER_FILES=()

for file in "${ALL_FILES[@]}"; do
  if [[ "$file" =~ (^|/)src/([^/]+/)?(main/)? ]]; then
    SRC_FILES+=("$file")
  elif [[ "$file" =~ (^|/)(tests|test|src/test)/ ]]; then
    TEST_FILES+=("$file")
  else
    OTHER_FILES+=("$file")
  fi
done

ORDERED_FILES=("${SRC_FILES[@]}" "${TEST_FILES[@]}" "${OTHER_FILES[@]}")

# === Dump files with checksums ===
dump_file_with_hashes() {
  local file="$1"
  echo "FILE: $file" >> "$OUT_FILE"
  echo "MD5:  $(md5sum "$file" | awk '{print $1}')" >> "$OUT_FILE"
  echo "SHA1: $(sha1sum "$file" | awk '{print $1}')" >> "$OUT_FILE"
  cat "$file" >> "$OUT_FILE"
  echo -e '\n' >> "$OUT_FILE"
}

for file in "${ORDERED_FILES[@]}"; do
  dump_file_with_hashes "$file"
done

for file in "${EXTRA_FILES[@]}"; do
  [[ -f "$file" ]] || continue
  dump_file_with_hashes "$file"
done

echo "âœ… Snapshot created: $OUT_FILE"
